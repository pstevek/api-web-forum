import logging
import httpx
import random
from sqlalchemy.exc import IntegrityError
from app.api.models import Role, User, Post, Like, Comment
from app.core.database import SessionLocal
from app.core.config import settings
from slugify import slugify
from datetime import datetime
from passlib.context import CryptContext


pwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')

tables = {
    'roles': [
        Role(
            slug="moderator",
            name="Moderator",
            created_at=datetime.now()
        ),
        Role(
            slug="regular",
            name="Regular",
            created_at=datetime.now()
        )
    ],
    'users': [
        User(
            email="admin@gmail.com",
            first_name="Admin",
            last_name="User",
            username="admin",
            password=pwd_context.hash("admin"),
            role_id=1,
            created_at=datetime.now(),
        ),
        User(
            email="steve.kamanke@gmail.com",
            first_name="Steve",
            last_name="Kamanke",
            username="pstevek",
            password=pwd_context.hash('password'),
            role_id=2,
            created_at=datetime.now(),
        ),
        User(
            email="user@barrows.co.za",
            first_name="Test",
            last_name="User",
            username="user.barrows",
            password=pwd_context.hash('password'),
            role_id=2,
            created_at=datetime.now(),
        ),
    ],
    'posts': [],
    'comments': [],
    'likes': []
}


def run_seeder(db_tables: list) -> None:
    session = SessionLocal()
    for table in db_tables:
        try:
            session.bulk_save_objects(objects=tables[table])
            session.commit()
        except IntegrityError:
            logging.error("Duplicate transaction detected. Seeder likely ran already")


if __name__ == "__main__":
    _api_posts_endpoint = settings.SAMPLE_POSTS_API
    _api_users_endpoint = settings.SAMPLE_USERS_API

    try:
        _api_posts = httpx.get(f"{_api_posts_endpoint}?limit=100")
        _api_users = httpx.get(f"{_api_users_endpoint}?limit=100")

        _api_users.raise_for_status()
        users = _api_users.json()['users']
        for i in range(0, 50):
            tables['users'].append(
                User(
                    email=users[i]['email'],
                    first_name=users[i]['first_name'],
                    last_name=users[i]['last_name'],
                    username=f"{users[i]['first_name']}.{users[i]['last_name']}".lower(),
                    password=pwd_context.hash('password'),
                    role_id=2,
                    created_at=datetime.now(),
                )
            )

        _api_posts.raise_for_status()
        blogs = _api_posts.json()['blogs']
        for i in range(0, 100):
            tables['posts'].append(
                Post(
                    user_id=random.randint(2, 50),
                    title=blogs[i]['title'],
                    slug=f"{slugify(blogs[i]['title'])}-{i}",
                    content=blogs[i]['content_html']
                )
            )

        for _ in range(0, 50):
            tables['likes'].append(
                Like(
                    user_id=random.randint(2, 50),
                    post_id=random.randint(1, 100)
                )
            )

        for i in range(0, 50):
            tables['comments'].append(
                Comment(
                    user_id=random.randint(2, 50),
                    post_id=random.randint(1, 100),
                    content=f"Autogenerated comment #{i}"
                )
            )
    except httpx.RequestError as exc:
        print(f"An error occurred while requesting {exc.request.url!r}.")
    except httpx.HTTPStatusError as exc:
        print(f"Error response {exc.response.status_code} while requesting {exc.request.url!r}.")

    run_seeder([*tables])
